{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome!","text":"<p>Here you will find information that will help you to get started developing the Tracery application. Tracery is a web application implemented on the stack of React + NestJS. The documentation covers both back-end and front-end parts.</p> <p>The documentation serves two main purposes:</p> <ol> <li>Answer common questions arising during development</li> <li>Document things that have already been implemented</li> </ol> <p>The documentation tries to address the following questions:</p> <ol> <li>How to write consistent code in general?</li> <li>How do we collaborate together?</li> <li>How to structure my code?</li> <li>How to use {...} library?</li> </ol> <p>The information about application modules  can be found here.</p>"},{"location":"code-style/","title":"Code Style","text":"<p>Here is the guide how to properly write your TypeScript code. It doesn't cover the best practises of libraries or tools. To learn more about, let's say, React, go to the proper section.</p>"},{"location":"code-style/#pascalcase-is-the-way","title":"PascalCase is the way","text":"<p>Always use 1. PascalCase for classes or 2. pascalCase for everything else</p> <pre><code>class HumanManager { // Here PascalCase\n  constructor (\n    private readonly name: string,\n    private readonly surname: string,\n  ) {}\n\n  get fullName(): string { // ...and here pascalCase\n    return `${this.name} ${this.surname}`\n  }\n}\n\n// Here, again, pascalCase\nconst reallyLongIdentifier = new HumanManager('Mateusz', 'Nowak')\n</code></pre>"},{"location":"code-style/#tab-size-is-2-spaces","title":"Tab size is 2 spaces","text":"<p>You will deal with deeply nested JSX tags, like:</p> <pre><code>&lt;Container&gt;\n  &lt;Section&gt;\n    &lt;AnotherSection&gt;\n      &lt;SomeComponent /&gt;\n    &lt;/AnotherSection&gt;\n  &lt;/Section&gt;\n&lt;/Container&gt;\n</code></pre> <p>having tab size being equal to 4 spaces makes your code less readable. Tab size of 2 makes code more compact, therefore much more readable</p>"},{"location":"code-style/#dont-use-semicolons-unless-really-needed","title":"Don't use semicolons (unless really needed)","text":"<pre><code>const a = 1\nconst b = 2\nconsole.log(a + b)\n</code></pre> <p>TypeScript compiles down to JavaScript with automatically inserted semicolons. In some rare cases, however, they are necessary, and only then they should be inserted. If you see red errors around [] or (), try inserting a semicolon</p>"},{"location":"code-style/#try-not-to-omit-brackets-in-compound-statements","title":"Try not to omit brackets in compound statements","text":"<pre><code>// Bad\nif (something)\n  doSomething()\n\n// Good\nif (something) {\n  doSomething()\n}\n</code></pre>"},{"location":"code-style/#embrace-single-quotes","title":"Embrace single quotes:","text":"<pre><code>import { React } from 'react'\nimport { css } from 'styled-components'\n</code></pre> <p>They are faster to type. It will be a standard preference for our codebase. Use double quotes only when the string contains a single quote:</p> <pre><code>const quotedString = \"'Mateusz'\"\n</code></pre>"},{"location":"code-style/#dont-write-long-lines-split-them","title":"Don't write long lines. Split them!","text":"<pre><code>// Bad\nconst measurement = measureVelocity(valueA, valueB, valueC, valueD, valueE)\n\n// Good\nconst measurement = measureVelocity(\n  valueA,\n  valueB,\n  valueC,\n  valueD,\n  valueE,\n)\n\n// Bad\n&lt;MyComponent propA={{ ...something }} propB={10.0} propC /&gt;\n\n// Good\n&lt;MyComponent\n  propA={\n    ...something,\n  }}\n  propB={10.0}\n  propC\n/&gt;\n</code></pre>"},{"location":"code-style/#use-trailing-commas","title":"Use trailing commas","text":"<p>JavaScript allows you to have trailing commas in function calls, objects and arrays</p> <pre><code>const schema = {\n  type: 'post',\n  payload: {\n    name: 'Mateusz',\n    surname: 'Nowak', // here is trailing comma\n  }, // here is trailing comma\n}\n</code></pre>"},{"location":"code-style/#use-arrow-functions","title":"Use arrow functions","text":"<p>Arrow functions' behavior is more predictable (I am primarily talking about this). Therefore, when possible, you should use them:</p> <pre><code>\n// an arrow function\nconst App = () =&gt; {\n  return (\n    &lt;main&gt;\n      &lt;h1&gt;Hello, world!&lt;/h1&gt;\n    &lt;/main&gt;\n  )\n}\n\n// another arrow function\nconst add = (a: number, b: number) =&gt; a + b\n\n// you can use them as methods in classes\nclass Person {\n  constructor (\n    public readonly name: string,\n    public readonly surname: string,\n  ) {}\n\n  greet = (friend: Person) =&gt; {\n    const greeting = `Hi, ${friend.name}, I am ${this.name}!`\n    console.log(greeting)\n  }\n}\n\n</code></pre>"},{"location":"code-style/#allow-typescript-to-infer-types-when-possible","title":"Allow TypeScript to infer types when possible","text":"<p>TypeScript type inference works well most of the times. In fact, when type inference is possible, TypeScript will definitely infer types better than you. So, use types only when needed (normally for function arguments)</p> <pre><code>// Not needed - TypeScript already knows that a is a string\nconst a: string = 'Hello, world' // type of a is 'string'\n\nconst a = 'Hello, world!' // type of a is a literal 'Hello, world!'\n                          // the type here is more narrow since TypeScript\n                          // knows that a cannot be changed to\n                          // any other string\n\n// why do you need \": number\" in the end?\nconst add = (a: number, b: number): number =&gt; a + b\n\n// this one is better: TS already knows \n// that the function returns a number\nconst add = (a: number, b: number) =&gt; a + b\n</code></pre>"},{"location":"code-style/#dont-use-any","title":"Don't use any","text":"<p>Type 'any' kills the TypeScript type system. The moment you introduce 'any' to your codebase, you allow bad things to happen. Don't do that.</p> <p>Consider reading on the internet how to:</p> <ol> <li>Use 'unknown' type instead</li> <li>Use generics</li> <li>Use type guards with validation</li> </ol> <p>Normally 'any' occurs when you get something as a network response. Then, you need to validate the response and prove that it has the desired type using type guards</p> <pre><code>// Example of a type guard validation\n\ntype Person = {\n  name: string\n  surname: string\n}\n\nconst isPerson = (maybePerson: unknown): maybePerson is Person =&gt; {\n  if (maybePerson === undefined || maybePerson === null) {\n    return false\n  }\n  if (typeof maybePerson !== 'object') {\n    return false\n  }\n  if (typeof maybePerson?.name !== 'string' ||\n      typeof maybePerson?.surname !== 'string) {\n    return false\n  }\n  return true\n}\n\n// in some other place\nconst person = await fetchPerson() // type of person is any\nif (isPerson(person)) {\n  // Here TypeScript knows, \n  // that if isPerson returned true,\n  // type of the person is Person\n  console.log(person.name) // No error\n}\n\n</code></pre>"},{"location":"code-style/#dont-use-typescript-enums-and-namespaces","title":"Don't use TypeScript enums and namespaces","text":"<p>Instead of enums you can use const enums. Namespaces are just a language design mistake, nobody uses them, so you shouldn't either</p>"},{"location":"code-style/#use-typescript-const-enums","title":"Use TypeScript const enums","text":"<p>const enums are quite useful. They are similar to C macroses. During compilation, they are turned into just JavaScript literals</p> <pre><code>const enum Status {\n  ON = 'On',\n  OFF = 'Off',\n  UNKNOWN = 'Unknown'\n}\n\nconst status = Status.OFF // after compilation,\n                          // it will be just const status = 'Off'\n\n// You can skip literals in const enum definition,\n// then TypeScript will use numbers 0, 1, 2, ...\nconst enum Flag {\n  READ,\n  WRITE,\n}\n\nconst flag = Flag.READ // after compilation,\n                       // const flag = 0\n</code></pre>"},{"location":"code-style/#dont-use-interfaces-use-types-instead","title":"Don't use interfaces, use types instead","text":"<p>Attention! Both types and interfaces do the same thing!    In other languages there may be a distinction between those two.   TypeScript, however, is a language with duck typing, therefore   each type acts as an interface by default </p> <p>In TypeScript you have two ways of declaring a type:</p> <ol> <li>Interface declaration</li> <li>Type declaration</li> </ol> <pre><code>// preferred way\ntype User = {\n  name: string\n  surname: string\n}\n\n// Bad - don't use it\ninterface User {\n  name: string\n  surname: string\n}\n</code></pre> <p>The reason behind this decision is the fact that interfaces are quite limited, and all their use-cases are covered with type definitions.</p>"},{"location":"code-style/#ask-about-the-rest","title":"Ask about the rest","text":"<p>If you are unsure about something, just ask me :)</p>"},{"location":"git-and-github/","title":"Git and Github","text":"<p>Github is the central part of our collaboration. Our application source code is hosted under the single organization called Tracery Team.</p> <p>We have 3 main repositories:</p> <ol> <li>Documentation</li> <li>Front-End</li> <li>Back-End</li> </ol>"},{"location":"git-and-github/#getting-started","title":"Getting Started","text":""},{"location":"git-and-github/#git","title":"Git","text":"<p>First of all, you need to install Git itself. You can run the following command to check whether you have it installed on your system:</p> <pre><code>git --version\n</code></pre> <p>if git is not found, then follow these instructions</p> <p>Git is the only obligatory program. And if you are using modern IDEs, only Git should be enough. Many of modern IDEs have a good Git integration. So, I encourage you to use the WebStorm JetBrains product. It will help you to track your Git history, pull changes from the remote, and resolve conflicts.</p> <p>JetBrains offers free licenses for students, so you should figure out how to get one. I got mine from GitHub Education pack. You can get WebStorm here: Download Link</p> <p>VSCode is another option. You will have to  spend more time installing plugins, so when you install the IDE itself, search for Git plugins available on the Extension marketplace.</p> <p>However, there are still some useful programs that you may consider installing:</p>"},{"location":"git-and-github/#github-desktop","title":"GitHub Desktop","text":"<p>I personally don't use it, but this tool may simplify the git and github workflow for you. Here you can download it: Download Link</p>"},{"location":"git-and-github/#sourcetree","title":"Sourcetree","text":"<p>Again, I personally don't use it, but Sourcetree shows you a beautiful graph of branches and commits. Sometimes it helps in understanding what's going on in the repository. Pretty nice program.  You can install it here: Download Link</p>"},{"location":"git-and-github/#gitgraph","title":"GitGraph","text":"<p>I indeed use it. Console application  that shows you beautiful Git branch&amp;commit graphs. You can install it here: Download Link</p>"},{"location":"git-and-github/#how-to-use-git","title":"How to use Git?","text":"<p>My personal advice: use git + gitgraph from command line, and your IDE for conflicts resolution. All other tools introduce unnecessary complexity. Command-line Git itself is simple enough, and you don't need any other programs to be successful.</p>"},{"location":"git-and-github/#list-of-most-popular-commands","title":"List of most popular commands","text":"<p>Here is the list of commands that you will be using:</p> <pre><code># To download a repository locally\ngit clone https://github.com/tracery-team/{repository}\n\n# Switch to git branch of your need\ngit checkout &lt;branch&gt;\n\n# Check what has changed on GitHub - maybe someone added a new branch\ngit fetch\n\n# Apply changes on GitHub to your current branch\ngit pull\n\n# Check the status of your changes\ngit status\n\n# See the changes (it will show you the changes in code)\ngit diff\n\n# Add files to staging area - before commit\ngit add . # all files\ngit add src/* # only needed files\n\n# Commit changes - adds a comit to your history\ngit commit -m \"feat(Header): added styling\"\n\n# Before commit, you may want to delete some file\n# from staging area, if you don't want to share it\ngit rm &lt;file&gt;\n\n# Post your changes on GitHub\ngit push\n\n# Discard changes, rollback to the last commit\ngit stash\n\n# If you messed up something, rollback to any commit\ngit reset --hard &lt;commit&gt;\n\n# If you want to apply changes from another branch, do\ngit merge &lt;branch&gt;\n</code></pre>"},{"location":"git-and-github/#popular-scenarios","title":"Popular scenarios","text":""},{"location":"git-and-github/#adding-a-feature","title":"Adding a feature","text":"<pre><code># You created a new issue on github with a branch\n# and you need to work on something using that branch\n\n# Get the remote changes from github\ngit fetch\ngit checkout feature-branch\n\n# Now you are on the feature-branch\n\n# Coding...\n# Coding...\n\n# Check what you did:\ngit status\ngit diff\n\n# Add your changes to staging area:\ngit add src/my-feature/*\n\n# Check whether everything is OK:\ngit status\n\n# Committing changes:\ngit commit -m \"feat(src/my-feature): added a feature\"\n\n# Let everybody know about your changes,\n# publish them online on GitHub:\ngit push\n</code></pre>"},{"location":"git-and-github/#downloading-changes","title":"Downloading Changes","text":"<pre><code># Imagine somebody did the previous scenario,\n# and then merged their changes to `main` branch.\n# You have an old `main` branch locally,\n# and you would like to update it\n\n# First of all, check whether\n# you have any remote changes\ngit fetch\n\n# Normally it will show you\n# what has changed remotely\n\n# Now, you need to switch to your\n# main branch\ngit checkout main\n\n# Update the main branch\ngit pull\n\n# Now you have an up-to-date main branch\n</code></pre>"},{"location":"git-and-github/#using-changes-from-other-branches","title":"Using changes from other branches","text":"<pre><code># Imagine that someone is working on a branch\n# called feature-2. They implemented things that you\n# wish you had on your branch\n\n# merge their branch into your current branch\ngit merge feature-2\n\n# Oh no! There are some conflicts.\n# Resolve the conflicts using your IDE\n\n# Continue the merge\ngit merge --continue\n</code></pre>"},{"location":"git-and-github/#to-gitignore-or-not-to-gitignore","title":"To .gitignore or not to .gitignore","text":"<p>Some files should not be tracked by git. They should nor be present in your local history, neither on GitHub.</p> <p>This includes:</p> <ol> <li>Environment variables files like .env, .env.runtime, etc.</li> <li>Files created by your IDE, like .idea, .vscode, etc.</li> <li>Files created by your programming platform, like node_modules</li> <li>Files created by your operating system, like .DS_Store</li> <li>Cache files</li> </ol> <p>And many, many more. The reason we don't want them to be on our version control system could be one of the following:</p> <ol> <li>They are large (node_modules can contain hundreds of megabytes)</li> <li>They contain sensitive data (like .env files, where you put passwords and API keys)</li> <li>They are unnecessary (everybody uses a different IDE, so why should we have your IDE files in our repo?)</li> <li>They may lead to inconsistencies</li> </ol> <p>There are two ways to deal with those files:</p> <ol> <li>Add them to .gitignore (the preferred way)</li> <li>Not adding them to staging area before commit: they will be excluded from commmit</li> </ol>"},{"location":"git-and-github/#conventional-commits","title":"Conventional Commits","text":"<p>When you do a commit, you can and must attach a message using -m flag. However, without proper rules on how to write your commit messages, they will quickly become pretty random.</p> <p>And here come the Conventional Commits You can read about them here. To put it shortly, it's a convention that tells you how to properly write commit messages</p> <p>Bad commit messages:</p> <ol> <li>small changes</li> <li>fixed the bug</li> <li>added styling</li> <li>commit commit</li> </ol> <p>Good commit messages:</p> <ol> <li>feat(footer): changed application footer</li> <li>fix(navigation): removed dead links from the navigation</li> <li>docs(src/components/CronPicker): added documentation for arguments</li> </ol>"},{"location":"git-and-github/#clear-and-intuitive-collaboration","title":"Clear and Intuitive Collaboration","text":"<p>There are best practices on how to work on a project together.</p> <p>Imagine if everybody was using the same branch. You make changes, you commit, you push... and boom! You get a notification that your branches are divergent. What could happen:</p> <ol> <li>Last commit on <code>main</code> branch is <code>A</code></li> <li>You and Mateusz simultaneously start working on that branch</li> <li>Mateusz finishes first, he commits his changes as commit <code>B</code> and immediately pushes it to GitHub</li> <li>Remotely, <code>main</code> branch has a history of <code>A -&gt; B</code></li> <li>You finish your changes and commit them as commit <code>C</code></li> <li>Your local history of <code>main</code> looks like <code>A -&gt; C</code></li> <li>When you push it to GitHub, it gets confused on what happened: how to treat the fact that you dont have the <code>B</code> commit?</li> </ol> <p>Even when working in a pair, bad git practices can lead to serious consequences. So, people invented something which is called  Gitflow: a tool and a set of rules that tells you how to organize your git collaboration on a project.</p> <p>We won't use Gitflow, but we will have some rules on how we work with our repositories, so we won't have to resolve divergent branches and merge conflicts.</p>"},{"location":"git-and-github/#our-plan-of-work","title":"Our plan of work","text":"<ol> <li>We need a feature. I, as a team leader, create an Issue on Github, assign some priority to this issue, and assign a person responsible for this issue.</li> <li>You, the person assigned to the issue, go to GitHub, click 'Create branch for the issue', git fetch &amp; git checkout to that branch locally, and start working on that feature on your separate branch</li> <li>This is YOUR branch, and noone should modify it except of you! Only one person is working per branch.</li> <li>After you've done with your feature, you merge the <code>main</code> branch to your branch, and resolve conflicts</li> <li>After the conflicts are resolved, you create a Pull Request on GitHub</li> <li>I check the PR, and make a code review. You change the code if it doesn't meet the criteria</li> <li>When I assume that the code is good enough, I merge your PR to the <code>main</code> branch</li> <li>You should NEVER modify the main branch, we are only merging to it. Want to add a feature? Create a separate Issue and a branch for that issue!</li> </ol>"}]}