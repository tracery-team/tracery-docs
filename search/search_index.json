{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome!","text":"<p>Here you will find information that will help you to get started developing the Tracery application. Tracery is a web application implemented on the stack of React + NestJS. The documentation covers both back-end and front-end parts.</p> <p>The documentation serves two main purposes:</p> <ol> <li>Answer common questions arising during development</li> <li>Document things that have already been implemented</li> </ol> <p>The documentation tries to addresses the following parts:</p> <ol> <li>Project git and github details</li> <li>Application setup</li> <li>Backend documentation</li> <li>Frontend documentation</li> </ol> <p>The information about application modules can be found here.</p>"},{"location":"app-modules/","title":"Project Modules","text":""},{"location":"app-modules/#frontend-modules","title":"Frontend Modules","text":"<ol> <li>React: A JavaScript library for building user interfaces.</li> <li>Redux: A predictable state container for JavaScript apps.</li> <li>React Router: A collection of navigational components for React applications.</li> <li>Axios: A promise-based HTTP client for the browser and Node.js.</li> <li>Material-UI: A popular React UI framework.</li> </ol>"},{"location":"app-modules/#backend-modules","title":"Backend Modules","text":"<ol> <li>Express: A minimal and flexible Node.js web application framework.</li> <li>PostgreSQL: A powerful, open-source object-relational database system.</li> <li>jsonwebtoken: A library to work with JSON Web Tokens (JWT).</li> <li>bcryptjs: A library to hash passwords.</li> <li>dotenv: A module to load environment variables from a <code>.env</code> file.</li> </ol>"},{"location":"app-modules/#additional-modules","title":"Additional Modules","text":"<ol> <li>Webpack: A module bundler for JavaScript applications.</li> <li>Babel: A JavaScript compiler.</li> <li>ESLint: A tool for identifying and reporting on patterns in JavaScript.</li> <li>Jest: A delightful JavaScript testing framework.</li> <li>Prettier: An opinionated code formatter.</li> </ol> <p>These modules collectively help in building and maintaining the project efficiently.</p>"},{"location":"backend/","title":"Backend","text":""},{"location":"backend/#backend-layer-and-data","title":"Backend Layer and Data","text":"<p>The backend layer of the project is responsible for handling the logic of the events with the users, as well as users with users and users with events. Through the use of Entity Models (here and here) as well as DTOs (Data Transfer Objects) (here and here) the backend communicates with the API and the PostgreSQL database to perform the CRUD operations. It is an intermediary between the frontend and the database, ensuring that data is processed and served correctly.</p> <p>For more information on the data layer, please refer to the Data Structure section.</p>"},{"location":"backend/#modules","title":"Modules","text":"<p>Modules are distinct components within the backend layer that encapsulate specific functionality and responsibilities. Each module focuses on a particular aspect of the project, ensuring a clear separation of concerns and improving maintainability. They interact with each other to provide a cohesive backend system that supports the overall application. In the project, the following modules have been implemented:</p> <ol> <li>Auth (authentication and authorization processes),</li> <li>Event (manages all event-related operations)</li> <li>Profile (responsible for managing user profiles, e.g. update personal information)</li> <li>User (user management, e.g. user registration)</li> </ol> <p>More information on the modules can be found in the Modules section.</p>"},{"location":"backend/#algorithms","title":"Algorithms","text":"<p>Throughout the code, the Levenshtein algorithm was used to measure the similarity between strings, which is particularly useful for functionalities such as user search and event matching. For more details on the implementation and usage of the Levenshtein algorithm, please refer to the Levenshtein Algorithm section.</p>"},{"location":"code-style/","title":"Code Style","text":"<p>Here is the guide how to properly write your TypeScript code. It doesn't cover the best practises of libraries or tools. To learn more about, let's say, React, go to the proper section.</p>"},{"location":"code-style/#pascalcase-is-the-way","title":"PascalCase is the way","text":"<p>Always use 1. PascalCase for classes or 2. pascalCase for everything else</p> <pre><code>class HumanManager { // Here PascalCase\n  constructor (\n    private readonly name: string,\n    private readonly surname: string,\n  ) {}\n\n  get fullName(): string { // ...and here pascalCase\n    return `${this.name} ${this.surname}`\n  }\n}\n\n// Here, again, pascalCase\nconst reallyLongIdentifier = new HumanManager('Mateusz', 'Nowak')\n</code></pre>"},{"location":"code-style/#tab-size-is-2-spaces","title":"Tab size is 2 spaces","text":"<p>You will deal with deeply nested JSX tags, like:</p> <pre><code>&lt;Container&gt;\n  &lt;Section&gt;\n    &lt;AnotherSection&gt;\n      &lt;SomeComponent /&gt;\n    &lt;/AnotherSection&gt;\n  &lt;/Section&gt;\n&lt;/Container&gt;\n</code></pre> <p>having tab size being equal to 4 spaces makes your code less readable. Tab size of 2 makes code more compact, therefore much more readable</p>"},{"location":"code-style/#dont-use-semicolons-unless-really-needed","title":"Don't use semicolons (unless really needed)","text":"<pre><code>const a = 1\nconst b = 2\nconsole.log(a + b)\n</code></pre> <p>TypeScript compiles down to JavaScript with automatically inserted semicolons. In some rare cases, however, they are necessary, and only then they should be inserted. If you see red errors around [] or (), try inserting a semicolon</p>"},{"location":"code-style/#try-not-to-omit-brackets-in-compound-statements","title":"Try not to omit brackets in compound statements","text":"<pre><code>// Bad\nif (something)\n  doSomething()\n\n// Good\nif (something) {\n  doSomething()\n}\n</code></pre>"},{"location":"code-style/#embrace-single-quotes","title":"Embrace single quotes:","text":"<pre><code>import { React } from 'react'\nimport { css } from 'styled-components'\n</code></pre> <p>They are faster to type. It will be a standard preference for our codebase. Use double quotes only when the string contains a single quote:</p> <pre><code>const quotedString = \"'Mateusz'\"\n</code></pre>"},{"location":"code-style/#dont-write-long-lines-split-them","title":"Don't write long lines. Split them!","text":"<pre><code>// Bad\nconst measurement = measureVelocity(valueA, valueB, valueC, valueD, valueE)\n\n// Good\nconst measurement = measureVelocity(\n  valueA,\n  valueB,\n  valueC,\n  valueD,\n  valueE,\n)\n\n// Bad\n&lt;MyComponent propA={{ ...something }} propB={10.0} propC /&gt;\n\n// Good\n&lt;MyComponent\n  propA={\n    ...something,\n  }}\n  propB={10.0}\n  propC\n/&gt;\n</code></pre>"},{"location":"code-style/#use-trailing-commas","title":"Use trailing commas","text":"<p>JavaScript allows you to have trailing commas in function calls, objects and arrays</p> <pre><code>const schema = {\n  type: 'post',\n  payload: {\n    name: 'Mateusz',\n    surname: 'Nowak', // here is trailing comma\n  }, // here is trailing comma\n}\n</code></pre>"},{"location":"code-style/#use-arrow-functions","title":"Use arrow functions","text":"<p>Arrow functions' behavior is more predictable (I am primarily talking about this). Therefore, when possible, you should use them:</p> <pre><code>\n// an arrow function\nconst App = () =&gt; {\n  return (\n    &lt;main&gt;\n      &lt;h1&gt;Hello, world!&lt;/h1&gt;\n    &lt;/main&gt;\n  )\n}\n\n// another arrow function\nconst add = (a: number, b: number) =&gt; a + b\n\n// you can use them as methods in classes\nclass Person {\n  constructor (\n    public readonly name: string,\n    public readonly surname: string,\n  ) {}\n\n  greet = (friend: Person) =&gt; {\n    const greeting = `Hi, ${friend.name}, I am ${this.name}!`\n    console.log(greeting)\n  }\n}\n\n</code></pre>"},{"location":"code-style/#allow-typescript-to-infer-types-when-possible","title":"Allow TypeScript to infer types when possible","text":"<p>TypeScript type inference works well most of the times. In fact, when type inference is possible, TypeScript will definitely infer types better than you. So, use types only when needed (normally for function arguments)</p> <pre><code>// Not needed - TypeScript already knows that a is a string\nconst a: string = 'Hello, world' // type of a is 'string'\n\nconst a = 'Hello, world!' // type of a is a literal 'Hello, world!'\n                          // the type here is more narrow since TypeScript\n                          // knows that a cannot be changed to\n                          // any other string\n\n// why do you need \": number\" in the end?\nconst add = (a: number, b: number): number =&gt; a + b\n\n// this one is better: TS already knows \n// that the function returns a number\nconst add = (a: number, b: number) =&gt; a + b\n</code></pre>"},{"location":"code-style/#dont-use-any","title":"Don't use any","text":"<p>Type 'any' kills the TypeScript type system. The moment you introduce 'any' to your codebase, you allow bad things to happen. Don't do that.</p> <p>Consider reading on the internet how to:</p> <ol> <li>Use 'unknown' type instead</li> <li>Use generics</li> <li>Use type guards with validation</li> </ol> <p>Normally 'any' occurs when you get something as a network response. Then, you need to validate the response and prove that it has the desired type using type guards</p> <pre><code>// Example of a type guard validation\n\ntype Person = {\n  name: string\n  surname: string\n}\n\nconst isPerson = (maybePerson: unknown): maybePerson is Person =&gt; {\n  if (maybePerson === undefined || maybePerson === null) {\n    return false\n  }\n  if (typeof maybePerson !== 'object') {\n    return false\n  }\n  if (typeof maybePerson?.name !== 'string' ||\n      typeof maybePerson?.surname !== 'string) {\n    return false\n  }\n  return true\n}\n\n// in some other place\nconst person = await fetchPerson() // type of person is any\nif (isPerson(person)) {\n  // Here TypeScript knows, \n  // that if isPerson returned true,\n  // type of the person is Person\n  console.log(person.name) // No error\n}\n\n</code></pre>"},{"location":"code-style/#dont-use-typescript-enums-and-namespaces","title":"Don't use TypeScript enums and namespaces","text":"<p>Instead of enums you can use const enums. Namespaces are just a language design mistake, nobody uses them, so you shouldn't either</p>"},{"location":"code-style/#use-typescript-const-enums","title":"Use TypeScript const enums","text":"<p>const enums are quite useful. They are similar to C macroses. During compilation, they are turned into just JavaScript literals</p> <pre><code>const enum Status {\n  ON = 'On',\n  OFF = 'Off',\n  UNKNOWN = 'Unknown'\n}\n\nconst status = Status.OFF // after compilation,\n                          // it will be just const status = 'Off'\n\n// You can skip literals in const enum definition,\n// then TypeScript will use numbers 0, 1, 2, ...\nconst enum Flag {\n  READ,\n  WRITE,\n}\n\nconst flag = Flag.READ // after compilation,\n                       // const flag = 0\n</code></pre>"},{"location":"code-style/#dont-use-interfaces-use-types-instead","title":"Don't use interfaces, use types instead","text":"<p>Attention! Both types and interfaces do the same thing!    In other languages there may be a distinction between those two.   TypeScript, however, is a language with duck typing, therefore   each type acts as an interface by default </p> <p>In TypeScript you have two ways of declaring a type:</p> <ol> <li>Interface declaration</li> <li>Type declaration</li> </ol> <pre><code>// preferred way\ntype User = {\n  name: string\n  surname: string\n}\n\n// Bad - don't use it\ninterface User {\n  name: string\n  surname: string\n}\n</code></pre> <p>The reason behind this decision is the fact that interfaces are quite limited, and all their use-cases are covered with type definitions.</p>"},{"location":"code-style/#ask-about-the-rest","title":"Ask about the rest","text":"<p>If you are unsure about something, just ask me :)</p>"},{"location":"data/","title":"Data Structure","text":"<p>The data inside the project is divided into two <code>Data (Entity) Models</code> and two <code>DTOs (Data Transfer Objects)</code> that exist in the API Layer.</p> <pre><code>/src\n    /data\n        /event.dto.ts\n        /user.dto.ts\n        /event.entity.ts\n        /user.entity.ts\n</code></pre> <p>The two Entity Models exist in the Database Layer. They are the <code>UserEntity</code> and the <code>EventEntity</code>.</p> <p>The two DTOs in the API Layer are the <code>EventDto</code> and <code>UserDto</code>.</p>"},{"location":"data/#entity-models","title":"Entity Models","text":"<p><code>Entity Models</code> represent the structure of the data stored in the database. They define the schema of the database tables and include properties that map to the columns in those tables. They handle data persistence logic (like password hashing) and contain sensitive information. Each entity corresponds to a single table in the database.</p>"},{"location":"data/#database-layer","title":"Database Layer","text":"<p>The <code>Database Layer</code> is responsible for managing the data storage and retrieval operations. It interacts with the database to perform CRUD (Create, Read, Update, Delete) operations on the data. This layer ensures that the data is stored in a structured and efficient manner, and provides an interface for the application to access and manipulate the data.</p>"},{"location":"data/#data-transfer-objects-dto","title":"Data Transfer Objects (DTO)","text":"<p>The <code>DTOs</code> serve several important purposes in the application. These classes act as filters for sensitive data as they prevent exposing sensitive information like password hashes, ensuring that only the necessary data is exposed and transferred, enhancing security and performance.</p> <pre><code>@Exclude()\npassword: string  // Password is excluded from API responses\n</code></pre> <p>For example, the <code>EventDto</code> class represents the structure of an event object, including its id, title, description, location, date, and associated users. The <code>users</code> property is transformed to exclude sensitive information such as passwords and friends list from the user objects.</p>"},{"location":"data/#api-layer","title":"API Layer","text":"<p>The <code>API Layer</code> handles the communication between the client and the server. It uses DTOs to transfer data securely and efficiently, ensuring that sensitive information is not exposed. This layer processes incoming requests, applies business logic, and returns appropriate responses.</p> <ul> <li>Handles client-server communication</li> <li>Uses DTOs for secure data transfer</li> <li>Processes requests and applies business logic</li> <li>Returns appropriate responses</li> </ul>"},{"location":"data/#_1","title":"Data Structure","text":"<p>The architecture follows a clear separation between database entities and DTOs to ensure security and proper data encapsulation when sending responses through the API.</p>"},{"location":"data/#user-entity","title":"User Entity","text":"<p>The <code>UserEntity</code> is the core user model with database mappins using TypeORM decorators.</p>"},{"location":"data/#event-entity","title":"Event Entity","text":"<p>The <code>EventEntity</code> represents events in the system and maps to the events table in the database. It manages event information and participant relationships.</p>"},{"location":"data/#event-dto","title":"Event DTO","text":"<p>The <code>EventDto</code> is a Data Transfer Object that represents an event. It contains information about the event such as its ID, title, description, location, date, and associated users.</p>"},{"location":"data/#user-dto","title":"User DTO","text":"<p>The <code>UserDto</code> is a Data Transfer Object that represents a user. It contains information about the user such as their ID, nickname, first name, last name, email, friends, and events.</p>"},{"location":"data/#data-storage","title":"Data Storage","text":"<ul> <li>Events and users are stored in the PostgreSQL database</li> <li>Uses TypeORM decorators for database mapping</li> <li>Enforces unique event titles and user emails to prevent duplicates</li> </ul>"},{"location":"data/#user-relationships","title":"User Relationships","text":"<ul> <li>Maintains many-to-many relationship with events</li> <li>Bidirectional mapping with EventEntity</li> <li>Allows tracking event participants and user events</li> </ul>"},{"location":"data/#event-relationships","title":"Event Relationships","text":"<ul> <li>Each event can have multiple participants</li> <li>Maintains many-to-many relationship with users</li> <li>Uses join tables to manage event-user associations</li> <li>Allows querying events by participants and vice versa</li> <li>Ensures referential integrity between events and users</li> </ul>"},{"location":"data/#data-transfer","title":"Data Transfer","text":"<ul> <li>API responses use EventDto and UserDto</li> <li>Sensitive user data is filtered from participant lists</li> <li>Maintains clean data structure for frontend consumption</li> <li>Ensures secure and efficient data transfer between client and server</li> </ul>"},{"location":"git-and-github/","title":"Git and Github","text":"<p>Github is the central part of our collaboration. Our application source code is hosted under the single organization called Tracery Team.</p> <p>We have 3 main repositories:</p> <ol> <li>Documentation</li> <li>Front-End</li> <li>Back-End</li> </ol>"},{"location":"git-and-github/#getting-started","title":"Getting Started","text":""},{"location":"git-and-github/#git","title":"Git","text":"<p>First of all, you need to install Git itself. You can run the following command to check whether you have it installed on your system:</p> <pre><code>git --version\n</code></pre> <p>if git is not found, then follow these instructions</p> <p>Git is the only obligatory program. And if you are using modern IDEs, only Git should be enough. Many of modern IDEs have a good Git integration. So, I encourage you to use the WebStorm JetBrains product. It will help you to track your Git history, pull changes from the remote, and resolve conflicts.</p> <p>JetBrains offers free licenses for students, so you should figure out how to get one. I got mine from GitHub Education pack. You can get WebStorm here: Download Link</p> <p>VSCode is another option. You will have to  spend more time installing plugins, so when you install the IDE itself, search for Git plugins available on the Extension marketplace.</p> <p>However, there are still some useful programs that you may consider installing:</p>"},{"location":"git-and-github/#github-desktop","title":"GitHub Desktop","text":"<p>I personally don't use it, but this tool may simplify the git and github workflow for you. Here you can download it: Download Link</p>"},{"location":"git-and-github/#sourcetree","title":"Sourcetree","text":"<p>Again, I personally don't use it, but Sourcetree shows you a beautiful graph of branches and commits. Sometimes it helps in understanding what's going on in the repository. Pretty nice program.  You can install it here: Download Link</p>"},{"location":"git-and-github/#gitgraph","title":"GitGraph","text":"<p>I indeed use it. Console application  that shows you beautiful Git branch&amp;commit graphs. You can install it here: Download Link</p>"},{"location":"git-and-github/#how-to-use-git","title":"How to use Git?","text":"<p>My personal advice: use git + gitgraph from command line, and your IDE for conflicts resolution. All other tools introduce unnecessary complexity. Command-line Git itself is simple enough, and you don't need any other programs to be successful.</p>"},{"location":"git-and-github/#list-of-most-popular-commands","title":"List of most popular commands","text":"<p>Here is the list of commands that you will be using:</p> <pre><code># To download a repository locally\ngit clone https://github.com/tracery-team/{repository}\n\n# Switch to git branch of your need\ngit checkout &lt;branch&gt;\n\n# Check what has changed on GitHub - maybe someone added a new branch\ngit fetch\n\n# Apply changes on GitHub to your current branch\ngit pull\n\n# Check the status of your changes\ngit status\n\n# See the changes (it will show you the changes in code)\ngit diff\n\n# Add files to staging area - before commit\ngit add . # all files\ngit add src/* # only needed files\n\n# Commit changes - adds a comit to your history\ngit commit -m \"feat(Header): added styling\"\n\n# Before commit, you may want to delete some file\n# from staging area, if you don't want to share it\ngit rm &lt;file&gt;\n\n# Post your changes on GitHub\ngit push\n\n# Discard changes, rollback to the last commit\ngit stash\n\n# If you messed up something, rollback to any commit\ngit reset --hard &lt;commit&gt;\n\n# If you want to apply changes from another branch, do\ngit merge &lt;branch&gt;\n</code></pre>"},{"location":"git-and-github/#popular-scenarios","title":"Popular scenarios","text":""},{"location":"git-and-github/#adding-a-feature","title":"Adding a feature","text":"<pre><code># You created a new issue on github with a branch\n# and you need to work on something using that branch\n\n# Get the remote changes from github\ngit fetch\ngit checkout feature-branch\n\n# Now you are on the feature-branch\n\n# Coding...\n# Coding...\n\n# Check what you did:\ngit status\ngit diff\n\n# Add your changes to staging area:\ngit add src/my-feature/*\n\n# Check whether everything is OK:\ngit status\n\n# Committing changes:\ngit commit -m \"feat(src/my-feature): added a feature\"\n\n# Let everybody know about your changes,\n# publish them online on GitHub:\ngit push\n</code></pre>"},{"location":"git-and-github/#downloading-changes","title":"Downloading Changes","text":"<pre><code># Imagine somebody did the previous scenario,\n# and then merged their changes to `main` branch.\n# You have an old `main` branch locally,\n# and you would like to update it\n\n# First of all, check whether\n# you have any remote changes\ngit fetch\n\n# Normally it will show you\n# what has changed remotely\n\n# Now, you need to switch to your\n# main branch\ngit checkout main\n\n# Update the main branch\ngit pull\n\n# Now you have an up-to-date main branch\n</code></pre>"},{"location":"git-and-github/#using-changes-from-other-branches","title":"Using changes from other branches","text":"<pre><code># Imagine that someone is working on a branch\n# called feature-2. They implemented things that you\n# wish you had on your branch\n\n# merge their branch into your current branch\ngit merge feature-2\n\n# Oh no! There are some conflicts.\n# Resolve the conflicts using your IDE\n\n# Continue the merge\ngit merge --continue\n</code></pre>"},{"location":"git-and-github/#to-gitignore-or-not-to-gitignore","title":"To .gitignore or not to .gitignore","text":"<p>Some files should not be tracked by git. They should nor be present in your local history, neither on GitHub.</p> <p>This includes:</p> <ol> <li>Environment variables files like .env, .env.runtime, etc.</li> <li>Files created by your IDE, like .idea, .vscode, etc.</li> <li>Files created by your programming platform, like node_modules</li> <li>Files created by your operating system, like .DS_Store</li> <li>Cache files</li> </ol> <p>And many, many more. The reason we don't want them to be on our version control system could be one of the following:</p> <ol> <li>They are large (node_modules can contain hundreds of megabytes)</li> <li>They contain sensitive data (like .env files, where you put passwords and API keys)</li> <li>They are unnecessary (everybody uses a different IDE, so why should we have your IDE files in our repo?)</li> <li>They may lead to inconsistencies</li> </ol> <p>There are two ways to deal with those files:</p> <ol> <li>Add them to .gitignore (the preferred way)</li> <li>Not adding them to staging area before commit: they will be excluded from commmit</li> </ol>"},{"location":"git-and-github/#conventional-commits","title":"Conventional Commits","text":"<p>When you do a commit, you can and must attach a message using -m flag. However, without proper rules on how to write your commit messages, they will quickly become pretty random.</p> <p>And here come the Conventional Commits You can read about them here. To put it shortly, it's a convention that tells you how to properly write commit messages</p> <p>Bad commit messages:</p> <ol> <li>small changes</li> <li>fixed the bug</li> <li>added styling</li> <li>commit commit</li> </ol> <p>Good commit messages:</p> <ol> <li>feat(footer): changed application footer</li> <li>fix(navigation): removed dead links from the navigation</li> <li>docs(src/components/CronPicker): added documentation for arguments</li> </ol>"},{"location":"git-and-github/#clear-and-intuitive-collaboration","title":"Clear and Intuitive Collaboration","text":"<p>There are best practices on how to work on a project together.</p> <p>Imagine if everybody was using the same branch. You make changes, you commit, you push... and boom! You get a notification that your branches are divergent. What could happen:</p> <ol> <li>Last commit on <code>main</code> branch is <code>A</code></li> <li>You and Mateusz simultaneously start working on that branch</li> <li>Mateusz finishes first, he commits his changes as commit <code>B</code> and immediately pushes it to GitHub</li> <li>Remotely, <code>main</code> branch has a history of <code>A -&gt; B</code></li> <li>You finish your changes and commit them as commit <code>C</code></li> <li>Your local history of <code>main</code> looks like <code>A -&gt; C</code></li> <li>When you push it to GitHub, it gets confused on what happened: how to treat the fact that you dont have the <code>B</code> commit?</li> </ol> <p>Even when working in a pair, bad git practices can lead to serious consequences. So, people invented something which is called  Gitflow: a tool and a set of rules that tells you how to organize your git collaboration on a project.</p> <p>We won't use Gitflow, but we will have some rules on how we work with our repositories, so we won't have to resolve divergent branches and merge conflicts.</p>"},{"location":"git-and-github/#our-plan-of-work","title":"Our plan of work","text":"<ol> <li>We need a feature. I, as a team leader, create an Issue on Github, assign some priority to this issue, and assign a person responsible for this issue.</li> <li>You, the person assigned to the issue, go to GitHub, click 'Create branch for the issue', git fetch &amp; git checkout to that branch locally, and start working on that feature on your separate branch</li> <li>This is YOUR branch, and noone should modify it except of you! Only one person is working per branch.</li> <li>After you've done with your feature, you merge the <code>main</code> branch to your branch, and resolve conflicts</li> <li>After the conflicts are resolved, you create a Pull Request on GitHub</li> <li>I check the PR, and make a code review. You change the code if it doesn't meet the criteria</li> <li>When I assume that the code is good enough, I merge your PR to the <code>main</code> branch</li> <li>You should NEVER modify the main branch, we are only merging to it. Want to add a feature? Create a separate Issue and a branch for that issue!</li> </ol>"},{"location":"levenshtein/","title":"Levenshtein Distance","text":"<p>The Levenshtein distance is a metric for measuring the difference between two sequences. It is named after the Soviet mathematician Vladimir Levenshtein, who considered this distance in 1965. The Levenshtein distance between two strings is defined as the minimum number of single-character edits (insertions, deletions, or substitutions) required to change one string into the other.</p>"},{"location":"levenshtein/#implementation-in-typescript","title":"Implementation in TypeScript","text":"<p>The following TypeScript function calculates the Levenshtein distance between two strings, <code>s1</code> and <code>s2</code>:</p> <pre><code>export function levenshtein(s1: string, s2: string): number {\n  if (s1 === s2) {\n    return 0;\n  }\n\n  const s1_len = s1.length;\n  const s2_len = s2.length;\n  if (s1_len === 0) {\n    return s2_len;\n  }\n  if (s2_len === 0) {\n    return s1_len;\n  }\n\n  let v0 = new Array(s1_len + 1);\n  let v1 = new Array(s1_len + 1);\n\n  for (let i = 0; i &lt; s1_len + 1; i++) {\n    v0[i] = i;\n  }\n\n  for (let j = 1; j &lt;= s2_len; j++) {\n    v1[0] = j;\n    const char_s2 = s2[j - 1];\n\n    for (let i = 0; i &lt; s1_len; i++) {\n      const char_s1 = s1[i];\n      const cost = char_s1 === char_s2 ? 0 : 1;\n      const m_min = Math.min(v0[i + 1] + 1, v1[i] + 1, v0[i] + cost);\n      v1[i + 1] = m_min;\n    }\n\n    [v0, v1] = [v1, v0];\n  }\n\n  return v0[s1_len];\n}\n</code></pre>"},{"location":"levenshtein/#explanation","title":"Explanation","text":""},{"location":"levenshtein/#base-cases","title":"Base Cases:","text":"<ul> <li>If the two strings are identical, the distance is <code>0</code>.</li> <li>If one of the strings is empty, the distance is the length of the other string.</li> </ul>"},{"location":"levenshtein/#initialization","title":"Initialization:","text":"<ul> <li>Two arrays, <code>v0</code> and <code>v1</code>, are initialized to store the distances.</li> </ul>"},{"location":"levenshtein/#distance-calculation","title":"Distance Calculation:","text":"<ul> <li>The outer loop iterates over each character of <code>s2</code>.</li> <li>The inner loop iterates over each character of <code>s1</code>.</li> <li>The cost is <code>0</code> if the characters are the same, otherwise <code>1</code>.</li> <li>The minimum cost is calculated considering insertion, deletion, and substitution.</li> </ul>"},{"location":"levenshtein/#result","title":"Result:","text":"<ul> <li>The final distance is stored in <code>v0[s1_len]</code>.</li> </ul>"},{"location":"levenshtein/#applying-levenshtein-distance-in-search","title":"Applying Levenshtein Distance in Search","text":"<p>The <code>applySearch</code> function uses the Levenshtein distance to filter and sort elements based on their similarity to a target string.</p> <pre><code>export const applySearch = &lt;T&gt;(\n  elements: T[],\n  distanceFn: (element: T) =&gt; number,\n  maxDistance: number = 20\n) =&gt; {\n  const filteredElements = elements\n    .map((element) =&gt; {\n      return Object.freeze({\n        element,\n        distance: distanceFn(element),\n      });\n    })\n    .filter(({ distance }) =&gt; distance &lt;= maxDistance);\n  filteredElements.sort(({ distance: distanceA }, { distance: distanceB }) =&gt; {\n    const weight = distanceA - distanceB;\n    return weight;\n  });\n  return filteredElements.map(({ element }) =&gt; element);\n};\n</code></pre>"},{"location":"levenshtein/#explanation_1","title":"Explanation","text":""},{"location":"levenshtein/#mapping-elements","title":"Mapping Elements:","text":"<ul> <li>Each element is mapped to an object containing the element and its distance to the target string.</li> </ul>"},{"location":"levenshtein/#filtering","title":"Filtering:","text":"<ul> <li>Elements with a distance greater than <code>maxDistance</code> are filtered out.</li> </ul>"},{"location":"levenshtein/#sorting","title":"Sorting:","text":"<ul> <li>The remaining elements are sorted by their distance in ascending order.</li> </ul>"},{"location":"levenshtein/#result_1","title":"Result:","text":"<ul> <li>The sorted elements are returned.</li> </ul> <p>This function is useful for implementing search functionalities where results are ranked by their similarity to the search query.</p>"},{"location":"modules/","title":"Module Structure","text":"<p>The NestJS application is organized into modules that encapsulate related functionality. Each module is a cohesive block of code dedicated to a specific domain, feature, or functionality in the application.</p>"},{"location":"modules/#module-hierarchy","title":"Module Hierarchy","text":"<pre><code>/modules\n    /auth                       # Authentication and authorization\n        /auth.controller.ts\n        /auth.guard.ts\n        /auth.module.ts\n        /auth.service.ts\n        /login.dto.ts\n        /signup.dto.ts\n    /event                      # Event management\n        /event.controller.ts\n        /event.module.ts\n        /event.service.ts\n    /profile                    # User profile management\n        /profile.controller.ts\n        /profile.module.ts\n        /profile.service.ts\n    /user                       # User management\n        /user.controller.ts\n        /user.module.ts\n        /user.service.ts\n</code></pre>"},{"location":"modules/#module-details","title":"Module Details","text":""},{"location":"modules/#auth-module","title":"Auth Module","text":"<p>The <code>Auth Module</code> handles authentication and authorization processes. It provides:</p> <ul> <li>User signup and login functionality</li> <li>JWT token generation and validation</li> <li>Route protection with [<code>AuthGuard</code>]</li> <li>Validation of credentials using [<code>SignUpDto</code>] and [<code>LoginDto</code>]</li> </ul>"},{"location":"modules/#event-module","title":"Event Module","text":"<p>The <code>Event Module</code> manages all event-related operations through [<code>EventService</code>]:</p> <ul> <li>Creating and deleting events</li> <li>Searching events with pagination</li> <li>Managing event participants</li> <li>Retrieving event details</li> <li>Fuzzy search functionality using <code>Levenshtein</code> distance</li> </ul>"},{"location":"modules/#profile-module","title":"Profile Module","text":"<p>The <code>Profile Module</code> handles user profile operations via [<code>ProfileService</code>]:</p> <ul> <li>Retrieving user profile information</li> <li>Managing personal user data</li> <li>Protected by [<code>AuthGuard</code>] to ensure authentication</li> <li>Accessing relationships (friends, events)</li> </ul>"},{"location":"modules/#user-module","title":"User Module","text":"<p>The <code>User Module</code> manages user-related operations through [<code>UserService</code>]:</p> <ul> <li>User search functionality</li> <li>Friend management (add/remove)</li> <li>User data retrieval</li> <li>Relationship management</li> <li>Pagination and search features</li> </ul>"},{"location":"modules/#general-information","title":"General information","text":"<p>Each module follows NestJS's modular architecture pattern with:</p> <ul> <li>Controllers for handling HTTP requests</li> <li>Services for business logic</li> <li>Module classes for configuration and dependency injection</li> <li>DTOs for data validation where applicable</li> </ul>"},{"location":"setup/","title":"Application Setup Documentation","text":"<p>This document provides a step-by-step guide to setting up the application using NestJS. The setup involves configuring the main application module and the main entry file.</p>"},{"location":"setup/#prerequisites","title":"Prerequisites","text":"<p>Ensure you have the following installed:</p> <ul> <li>Node.js</li> <li>npm or yarn</li> <li>PostgreSQL</li> </ul>"},{"location":"setup/#environment-variables","title":"Environment Variables","text":"<p>Create a <code>.env</code> file in the root directory of your project and add the following environment variables:</p> <pre><code>DATABASE_HOST=your_database_host\nDATABASE_PORT=your_database_port\nDATABASE_USER=your_database_user\nDATABASE_PASSWORD=your_database_password\nDATABASE_NAME=your_database_name\nPORT=your_application_port\n</code></pre>"},{"location":"setup/#app-module-configuration","title":"App Module Configuration","text":"<p>The <code>AppModule</code> is the root module of the application. It imports and configures other modules and services.</p>"},{"location":"setup/#appmodulets","title":"app.module.ts","text":"<pre><code>import { Module } from \"@nestjs/common\";\nimport { AuthModule } from \"./modules/auth/auth.module\";\nimport { TypeOrmModule } from \"@nestjs/typeorm\";\nimport { UserEntity } from \"./data/user.entity\";\nimport { ProfileModule } from \"./modules/profile/profile.module\";\nimport { EventModule } from \"./modules/event/event.module\";\nimport { UserModule } from \"./modules/user/user.module\";\nimport { EventEntity } from \"./data/event.entity\";\n\n@Module({\n  imports: [\n    TypeOrmModule.forRoot({\n      type: \"postgres\",\n      host: process.env.DATABASE_HOST,\n      port: Number(process.env.DATABASE_PORT),\n      username: process.env.DATABASE_USER,\n      password: process.env.DATABASE_PASSWORD,\n      database: process.env.DATABASE_NAME,\n      entities: [UserEntity, EventEntity],\n      synchronize: true, // TODO: migrations\n    }),\n    AuthModule,\n    EventModule,\n    UserModule,\n    ProfileModule,\n  ],\n})\nexport class AppModule {}\n</code></pre>"},{"location":"setup/#explanation","title":"Explanation","text":"<ul> <li>TypeOrmModule.forRoot: Configures the TypeORM module to connect to a PostgreSQL database using environment variables.</li> <li>Entities: Specifies the entities used in the application (<code>UserEntity</code> and <code>EventEntity</code>).</li> <li>Modules: Imports other feature modules (<code>AuthModule</code>, <code>EventModule</code>, <code>UserModule</code>, <code>ProfileModule</code>).</li> </ul>"},{"location":"setup/#main-entry-file","title":"Main Entry File","text":"<p>The <code>main.ts</code> file is the entry point of the application. It bootstraps the NestJS application and applies global configurations.</p>"},{"location":"setup/#maints","title":"main.ts","text":"<pre><code>import \"dotenv/config\";\nimport { NestFactory } from \"@nestjs/core\";\nimport { AppModule } from \"./app.module\";\nimport { ValidationPipe } from \"@nestjs/common\";\n\nasync function bootstrap() {\n  const app = await NestFactory.create(AppModule);\n  app.useGlobalPipes(\n    new ValidationPipe({\n      whitelist: true,\n      transform: true,\n    })\n  );\n  await app.listen(process.env.PORT ?? 3000);\n}\nbootstrap();\n</code></pre>"},{"location":"setup/#explanation_1","title":"Explanation","text":"<ul> <li>dotenv/config: Loads environment variables from the <code>.env</code> file.</li> <li>NestFactory.create: Creates a new NestJS application instance using the <code>AppModule</code>.</li> <li>ValidationPipe: Applies global validation pipes to automatically validate incoming requests.</li> <li>app.listen: Starts the application on the specified port (default is 3000).</li> </ul>"},{"location":"setup/#running-the-application","title":"Running the Application","text":"<p>To run the application, use the following command:</p> <pre><code>npm run start\n</code></pre> <p>or</p> <pre><code>yarn start\n</code></pre> <p>Ensure your PostgreSQL database is running and the environment variables are correctly set up.</p>"},{"location":"data/EventDTO/","title":"EventDTO","text":"<p>The <code>EventDTO</code> is strictly connected to the <code>Event Entity</code>!</p>"},{"location":"data/EventDTO/#format","title":"Format","text":"<pre><code>// Importing the Transform decorator from the class-transformer library\n// This decorator is used to transform the values of class properties during the serialization and deserialization process\n\nimport { Transform } from \"class-transformer\";\n\n// Importing the UserDto class from the user.dto file\n// This class is a Data Transfer Object (DTO) used to define the structure of user-related data\nimport { UserDto } from \"./user.dto\";\n\nexport class EventDto {\n  id: number;\n  title: string;\n  description: string;\n  location: string;\n  date: Date;\n\n  @Transform(({ value }) =&gt; {\n    return value.map((user) =&gt; {\n      const { password, friends, ...safeUser } = user;\n      return safeUser;\n    });\n  })\n  users: UserDto[];\n}\n</code></pre>"},{"location":"data/EventDTO/#properties","title":"Properties","text":"<ul> <li><code>id</code>: Unique identifier for the event.</li> <li><code>title</code>: Event name/title.</li> <li><code>description</code>: Detailed event description.</li> <li><code>location</code>: Physical location where the event takes place.</li> <li><code>date</code>: Date and time of the event.</li> <li><code>users</code>: List of users participating in the event.</li> </ul>"},{"location":"data/EventDTO/#key-relationships","title":"Key Relationships","text":"<ul> <li><code>users</code>: Many-to-many relationship with <code>User DTO</code>, representing the users associated with the event. Sensitive information like passwords and friends list are excluded from the user objects.</li> </ul>"},{"location":"data/EventDTO/#key-features","title":"Key Features","text":"<ul> <li>Represents the structure of an event object.</li> <li>Ensures sensitive user data is excluded from API responses.</li> <li>Facilitates secure and efficient data transfer between client and server.</li> </ul>"},{"location":"data/EventEntity/","title":"EventEntity","text":"<p>The <code>Event Entity</code> is strictly connected to the <code>Event DTO</code>!</p>"},{"location":"data/EventEntity/#format","title":"Format","text":"<pre><code>@Entity()\nexport class EventEntity {\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column({ unique: true })\n  title: string;\n\n  @Column()\n  description: string;\n\n  @Column()\n  location: string;\n\n  @Column({ type: \"timestamptz\" })\n  date: Date;\n\n  @ManyToMany(() =&gt; UserEntity, (user) =&gt; user.events)\n  users: UserEntity[];\n}\n</code></pre>"},{"location":"data/EventEntity/#properties","title":"Properties","text":"<ul> <li><code>id</code>: Unique identifier for the event.</li> <li><code>title</code>: Event name/title (must be unique).</li> <li><code>description</code>: Detailed event description.</li> <li><code>location</code>: Physical location where the event takes place.</li> <li><code>date</code>: Date and time of the event (stored with timezone).</li> <li><code>users</code>: Many-to-many relationship with participating users.</li> </ul>"},{"location":"data/EventEntity/#key-relationships","title":"Key Relationships","text":"<ol> <li>Friends: Self-referential many-to-many relationship allowing <code>users</code> to connect with other users</li> <li>Events: Many-to-many relationship with events, tracking which events a user participates in</li> </ol> <pre><code>/**\n * Many-to-Many relationship with the UserEntity.\n * This property represents the users associated with the events. **/\n @type {UserEntity[]}\n  @ManyToMany(() =&gt; UserEntity, user =&gt; user.events)\n  users: UserEntity[]\n</code></pre> <p>The [<code>EventEntity</code>] forms the foundation of the application's social features and event participation system.</p>"},{"location":"data/EventEntity/#key-features","title":"Key Features","text":"<ul> <li>Events are stored in the PostgreSQL database.</li> <li>Uses TypeORM decorators for database mapping.</li> <li>Enforces unique event titles to prevent duplicates.</li> <li>Maintains many-to-many relationship with users.</li> <li>API responses use EventDto, filtering sensitive user data.</li> <li>Allows users to create, join, and track events.</li> </ul>"},{"location":"data/UserDTO/","title":"UserDTO","text":"<p>The <code>UserDTO</code> is strictly connected to the <code>User Entity</code>!</p>"},{"location":"data/UserDTO/#format","title":"Format","text":"<pre><code>//Importing necessary decorators and classes from external libraries and local files.\n// `Exclude` and `Transform` are decorators from the `class-transformer` library used for transforming and excluding properties during serialization and deserialization.\nimport { Exclude, Transform } from \"class-transformer\";\n// `EventDto` is a Data Transfer Object (DTO) imported from a local file, likely used to define the structure of event data.\nimport { EventDto } from \"./event.dto\";\n\nexport class UserDto {\n  id: number;\n  nickname: string;\n  firstName: string;\n  lastName: string;\n  email: string;\n\n  @Exclude()\n  password: string;\n\n  @Transform(({ value }) =&gt; {\n    const { friends, password, ...safeUser } = value;\n    return safeUser;\n  })\n  friends: UserDto[];\n\n  @Transform(({ value }) =&gt; {\n    const { password, friends, ...safeEventData } = value;\n    return safeEventData;\n  })\n  events: EventDto[];\n}\n</code></pre>"},{"location":"data/UserDTO/#properties","title":"Properties","text":"<ul> <li><code>id</code>: Unique identifier for the user.</li> <li><code>nickname</code>: User's unique nickname/username.</li> <li><code>firstName</code>: User's first name.</li> <li><code>lastName</code>: User's last name.</li> <li><code>email</code>: User's unique email address.</li> <li><code>password</code>: Hashed password (excluded from API responses).</li> <li><code>friends</code>: List of user's friends.</li> <li><code>events</code>: List of events the user participates in.</li> </ul>"},{"location":"data/UserDTO/#key-relationships","title":"Key Relationships","text":"<ul> <li><code>friends</code>: Many-to-many self-referential relationship with other <code>UserDto</code> objects, representing the user's friends. Sensitive information is excluded.</li> <li><code>events</code>: Many-to-many relationship with <code>EventDto</code>, representing the events the user participates in. Sensitive information is excluded.</li> </ul>"},{"location":"data/UserDTO/#key-features","title":"Key Features","text":"<ul> <li>Represents the structure of a user object.</li> <li>Ensures sensitive data like passwords and friends list are excluded from API responses.</li> <li>Facilitates secure and efficient data transfer between client and server.</li> <li>Maintains clean data structure for frontend consumption.</li> </ul>"},{"location":"data/UserEntity/","title":"UserEntity","text":"<p>The <code>User Entity</code> is strictly connected to the <code>User DTO</code></p>"},{"location":"data/UserEntity/#format","title":"Format","text":"<pre><code>@Entity()\nexport class UserEntity {\n  @PrimaryGeneratedColumn()\n  id: number;\n\n  @Column({ unique: true })\n  nickname: string;\n\n  @Column()\n  firstName: string;\n\n  @Column()\n  lastName: string;\n\n  @Column({ unique: true })\n  email: string;\n\n  @Column()\n  password: string;\n\n  @ManyToMany(() =&gt; UserEntity, (user) =&gt; user.friends)\n  @JoinTable()\n  friends: UserEntity[];\n\n  @ManyToMany(() =&gt; EventEntity, (event) =&gt; event.users)\n  @JoinTable()\n  events: EventEntity[];\n}\n</code></pre>"},{"location":"data/UserEntity/#properties","title":"Properties","text":"<ul> <li><code>id</code>: Unique identifier for the user.</li> <li><code>nickname</code>: User's unique nickname/username.</li> <li><code>firstName</code>: User's first name.</li> <li><code>lastName</code>: User's last name.</li> <li><code>email</code>: User's unique email address.</li> <li><code>password</code>: Hashed password (never exposed in API responses).</li> <li><code>friends</code>: Many-to-many self-referential relationship for friends.</li> <li><code>events</code>: Many-to-many relationship with events the user participates in.</li> </ul>"},{"location":"data/UserEntity/#key-relationships","title":"Key Relationships","text":"<p>It contains the essential user information and manages relationships with friends and events.</p> <p>The [<code>UserEntity</code>] has many-to-many relationships with:</p> <ol> <li>friends (self-referential relationship to other users)</li> </ol> <pre><code>@ManyToMany(() =&gt; UserEntity, user =&gt; user.friends)\n@JoinTable()\nfriends: UserEntity[]\n\n// This code defines a many-to-many relationship between the current entity and the UserEntity.\n// The @ManyToMany decorator specifies that each instance of the current entity can have many UserEntity instances as friends, and vice versa.\n// The @JoinTable decorator indicates that a join table should be created to manage this relationship.\n</code></pre> <ol> <li>events (bidirectional relationship with <code>EventEntity</code>)</li> </ol> <pre><code>  @ManyToMany(() =&gt; EventEntity, event =&gt; event.users)\n  @JoinTable()\n  events: EventEntity[]\n\n// This code defines a many-to-many relationship between the current entity and the EventEntity.\n// The @ManyToMany decorator specifies the relationship, and the @JoinTable decorator indicates that a join table should be created to manage the relationship.\n// The 'events' property will hold an array of EventEntity instances associated with the current entity.\n</code></pre> <p>It also includes the password hashing logic with bcrypt.</p> <pre><code>// The @BeforeInsert and @BeforeUpdate decorators are used to run the hashPassword method before inserting or updating the entity in the database.\n@BeforeInsert()\n@BeforeUpdate()\nasync hashPassword() {\n  // Generate a salt with 10 rounds for hashing the password\n  const salt = await bcrypt.genSalt(10)\n  // Hash the password with the generated salt and assign it to the password field\n  this.password = await bcrypt.hash(this.password, salt)\n}\n\n// This method validates the input password by comparing it with the hashed password stored in the database.\nvalidatePassword(inputPassword: string): Promise&lt;boolean&gt; {\n  // Compare the input password with the stored hashed password\n  return bcrypt.compare(inputPassword, this.password)\n}\n</code></pre>"},{"location":"data/UserEntity/#key-features","title":"Key Features","text":"<ul> <li>User management with unique identifiers, nicknames, and email addresses.</li> <li>Password hashing using bcrypt for enhanced security.</li> <li>Many-to-many relationships with friends and events.</li> <li>Automatic password hashing before saving to the database.</li> <li>Validation method for comparing input passwords with stored hashed passwords.</li> </ul>"},{"location":"modules/AuthModule/","title":"Auth Module","text":"<p>The <code>Auth Module</code> handles user authentication and authorization in the Tracery application. It provides functionality for user registration, login, and route protection using <code>JWT tokens</code>.</p> <p><code>JWT (JSON Web Tokens)</code> are a compact, URL-safe means of representing claims to be transferred between two parties. They are commonly used for authentication and authorization purposes. A JWT consists of three parts: a header, a payload, and a signature. The header typically consists of the token type and the signing algorithm. The payload contains the claims, which are statements about an entity (typically, the user) and additional data. The signature is used to verify that the sender of the JWT is who it says it is and to ensure that the message wasn't changed along the way.</p> <p>A <code>Data Transfer Object (DTO)</code>, for example <code>UserDTO</code> or <code>EventDTO</code> is a simple object that is used to transfer data between different parts of an application. DTOs are typically used to encapsulate data and send it from one subsystem of an application to another, such as from the client to the server or between different layers of an application. They help in ensuring that only the necessary data is exposed and transferred, promoting a clear separation of concerns and improving the maintainability of the code.</p>"},{"location":"modules/AuthModule/#core-components","title":"Core Components","text":""},{"location":"modules/AuthModule/#authentication-service","title":"Authentication Service","text":"<p>The [<code>AuthService</code>] handles the business logic for authentication:</p> <pre><code>@Injectable()\nexport class AuthService {\n  // User registration\n  async signUp(userData: Partial&lt;UserEntity&gt;): Promise&lt;SignupStatus&gt; {\n    // Creates new user in database\n    // Returns SUCCESS, DUPLICATE_ERR, or UNKNOWN_ERR\n  }\n\n  // User login with JWT generation\n  async login(login: string, password: string): Promise&lt;TokenJWT | null&gt; {\n    // Validates credentials and generates JWT token\n  }\n}\n</code></pre>"},{"location":"modules/AuthModule/#jwt-protection","title":"JWT Protection","text":"<p>The [<code>AuthGuard</code>] protects routes requiring authentication:</p> <pre><code>@Injectable()\nexport class AuthGuard implements CanActivate {\n  async canActivate(context: ExecutionContext): Promise&lt;boolean&gt; {\n    // Extracts JWT token from request header\n    // Validates token and adds user data to request\n    // Throws UnauthorizedException if invalid\n  }\n}\n</code></pre>"},{"location":"modules/AuthModule/#data-transfer-objects","title":"Data Transfer Objects","text":"<ol> <li><code>SignUpDto</code> - Validates registration data:</li> </ol> <pre><code>export class SignUpDto {\n  @IsNotEmpty()\n  @Matches(/^[_a-zA-Z][_a-zA-Z0-9]*$/)\n  @Length(4, 25)\n  nickname: string;\n\n  @IsEmail()\n  email: string;\n\n  @IsStrongPassword()\n  password: string;\n  // Additional fields...\n}\n</code></pre> <ol> <li><code>LoginDto</code> - Validates login credentials:</li> </ol> <pre><code>export class LoginDto {\n  @IsNotEmpty()\n  login: string; // Can be email or nickname\n\n  @IsNotEmpty()\n  password: string;\n}\n</code></pre>"},{"location":"modules/AuthModule/#key-features","title":"Key Features","text":""},{"location":"modules/AuthModule/#user-registration","title":"User Registration","text":"<ul> <li>Validates registration data using SignUpDto</li> <li>Checks for duplicate usernames/emails</li> <li>Automatically hashes passwords</li> </ul>"},{"location":"modules/AuthModule/#authentication","title":"Authentication","text":"<ul> <li>Supports login via email or nickname</li> <li>Validates password using bcrypt</li> <li>Generates JWT token on successful login</li> </ul>"},{"location":"modules/AuthModule/#route-protection","title":"Route Protection","text":"<ul> <li>Guards sensitive routes using @UseGuards(AuthGuard)</li> <li>Validates JWT tokens automatically</li> <li>Adds user context to requests</li> </ul>"},{"location":"modules/AuthModule/#api-endpoints","title":"API Endpoints","text":""},{"location":"modules/AuthModule/#post-authlogin","title":"POST /auth/login","text":"<p>Handles user login.</p> <ul> <li>Request Body: <code>LoginDto</code></li> <li><code>login</code> (string): User's email or nickname.</li> <li><code>password</code> (string): User's password.</li> <li>Response:</li> <li><code>200 OK</code>: <code>{ access_token: string }</code> - An object containing the access token.</li> <li><code>401 Unauthorized</code>: Invalid credentials.</li> </ul>"},{"location":"modules/AuthModule/#post-authsign-up","title":"POST /auth/sign-up","text":"<p>Handles user sign-up.</p> <ul> <li>Request Body: <code>SignUpDto</code></li> <li><code>nickname</code> (string): User's nickname.</li> <li><code>email</code> (string): User's email.</li> <li><code>password</code> (string): User's password.</li> <li>Response:</li> <li><code>201 Created</code>: <code>{ message: string }</code> - An object containing a success message.</li> <li><code>400 Bad Request</code>: Validation errors or duplicate username/email.</li> </ul> <pre><code>@Controller('auth')\nexport class AuthController {\n  @Post('login')\n  async login(@Body() loginDto: LoginDto)\n  // Returns: { access_token: string }\n\n  @Post('sign-up')\n  async signUp(@Body() signUpDto: SignUpDto)\n  // Returns: { message: string }\n}\n</code></pre>"},{"location":"modules/AuthModule/#module-configuration","title":"Module Configuration","text":"<p>The Profile module is configured in <code>auth.module.ts</code>:</p> <pre><code>@Module({\n  imports: [\n    TypeOrmModule.forFeature([UserEntity]),\n    JwtModule.register({\n      global: true,\n      secret: process.env.JWT_SECRET\n    })\n  ],\n  controllers: [AuthController],\n  providers: [AuthService]\n})\n</code></pre>"},{"location":"modules/AuthModule/#usage-example","title":"Usage Example","text":"<pre><code>@Controller(\"profile\")\n@UseGuards(AuthGuard) // Requires valid JWT\nexport class ProfileController {\n  @Get()\n  async getProfile(@Request() req: AuthorizedRequest) {\n    const userId = req.parsedToken.sub;\n    return this.profileService.getProfile(userId);\n  }\n}\n</code></pre> <p>The Auth module provides the foundation for secure user authentication and authorization throughout the application.</p>"},{"location":"modules/EventModule/","title":"Event Module","text":"<p>The <code>Event Module</code> manages all event-related operations in the Tracery application. It provides functionality for creating, searching, and managing <code>events</code>, as well as handling user participation in <code>events</code>.</p>"},{"location":"modules/EventModule/#core-components","title":"Core Components","text":""},{"location":"modules/EventModule/#event-service","title":"Event Service","text":"<p>The [<code>EventService</code>] handles event-related business logic:</p> <pre><code>@Injectable()\nexport class EventService {\n  // Find all events with user relationships\n  async findAll(): Promise&lt;EventDto[]&gt; {\n    const events = await this.eventRepository.find({\n      relations: [\"users\"],\n    });\n    return plainToInstance(EventDto, events);\n  }\n\n  // Search events with pagination and fuzzy search\n  async searchEvents(page: number, search?: string) {\n    // Uses Levenshtein distance for fuzzy search\n    // Returns paginated results\n  }\n\n  // Add user to event\n  async addEvent(userId: number, eventId: number) {\n    // Adds event to user's events list\n    // Prevents duplicate entries\n  }\n}\n</code></pre>"},{"location":"modules/EventModule/#event-controller","title":"Event Controller","text":"<p>The [<code>EventController</code>] exposes REST endpoints:</p> <pre><code>@Controller(\"event\")\nexport class EventController {\n  @Get()\n  async searchEvents(\n    @Query(\"page\") page: number = 1,\n    @Query(\"search\") search?: string\n  ) {\n    return this.eventService.searchEvents(page, search);\n  }\n\n  @Post(\"add\")\n  @UseGuards(AuthGuard)\n  async addEvent(\n    @Request() request: AuthorizedRequest,\n    @Body(\"eventId\") eventId: number\n  ) {\n    // Protected endpoint for adding events\n  }\n}\n</code></pre>"},{"location":"modules/EventModule/#key-features","title":"Key Features","text":""},{"location":"modules/EventModule/#event-management","title":"Event Management","text":"<ul> <li>Creating and retrieving events</li> <li>Managing event details (title, description, location, date)</li> <li>Handling event-user relationships</li> </ul>"},{"location":"modules/EventModule/#search-functionality","title":"Search Functionality","text":"<ul> <li>Fuzzy search using <code>Levenshtein</code> distance</li> <li>Searches through event titles and dates</li> <li>Paginated results with configurable page size</li> </ul>"},{"location":"modules/EventModule/#user-participation","title":"User Participation","text":"<ul> <li>Adding users to events</li> <li>Removing users from events</li> <li>Preventing duplicate event participation</li> </ul>"},{"location":"modules/EventModule/#data-protection","title":"Data Protection","text":"<ul> <li>Route protection using AuthGuard</li> <li>Validation of user permissions</li> <li>Safe data transformation using DTO</li> </ul>"},{"location":"modules/EventModule/#api-endpoints","title":"API Endpoints","text":""},{"location":"modules/EventModule/#api-endpoints_1","title":"API Endpoints","text":""},{"location":"modules/EventModule/#search-events","title":"Search Events","text":"<pre><code>GET /event?page=1&amp;search=query\n// Returns paginated list of events matching search\n</code></pre> <p>Request Body:</p> <ul> <li>None</li> </ul> <p>Responses:</p> <ul> <li><code>200 OK</code>: Returns a list of events matching the search criteria.</li> <li><code>400 Bad Request</code>: Invalid query parameters.</li> </ul>"},{"location":"modules/EventModule/#add-event-participation","title":"Add Event Participation","text":"<pre><code>POST / event / add;\nBody: {\n  eventId: number;\n}\n// Requires authentication\n// Adds current user to event\n</code></pre> <p>Request Body:</p> <ul> <li><code>eventId</code> (number): The ID of the event to add the user to.</li> </ul> <p>Responses:</p> <ul> <li><code>200 OK</code>: Event added successfully.</li> <li><code>400 Bad Request</code>: Invalid event ID or user already added.</li> <li><code>401 Unauthorized</code>: User not authenticated.</li> </ul>"},{"location":"modules/EventModule/#remove-event-participation","title":"Remove Event Participation","text":"<pre><code>DELETE / event / remove;\nBody: {\n  eventId: number;\n}\n// Requires authentication\n// Removes current user from event\n</code></pre> <p>Request Body:</p> <ul> <li><code>eventId</code> (number): The ID of the event to remove the user from.</li> </ul> <p>Responses:</p> <ul> <li><code>200 OK</code>: Event removed successfully.</li> <li><code>400 Bad Request</code>: Invalid event ID or user not part of the event.</li> <li><code>401 Unauthorized</code>: User not authenticated.</li> </ul>"},{"location":"modules/EventModule/#get-event-details","title":"Get Event Details","text":"<pre><code>GET /event/:id\n// Returns detailed event information\n// Includes participant list\n</code></pre> <p>Request Body:</p> <ul> <li>None</li> </ul> <p>Responses:</p> <ul> <li><code>200 OK</code>: Returns detailed information about the event.</li> <li><code>404 Not Found</code>: Event not found.</li> <li><code>400 Bad Request</code>: Invalid event ID.</li> </ul>"},{"location":"modules/EventModule/#module-configuration","title":"Module Configuration","text":"<p>The Event module is configured in <code>event.module.ts</code>:</p> <pre><code>@Module({\n  imports: [TypeOrmModule.forFeature([EventEntity, UserEntity])],\n  controllers: [EventController],\n  providers: [EventService],\n})\nexport class EventModule {}\n</code></pre>"},{"location":"modules/EventModule/#usage-example","title":"Usage Example","text":"<pre><code>// Adding a user to an event\n@Post('add')\n@UseGuards(AuthGuard)\nasync addEvent(\n  @Request() request: AuthorizedRequest,\n  @Body('eventId') eventId: number,\n) {\n  const userId = request.parsedToken.sub;\n  const result = await this.eventService.addEvent(userId, eventId);\n  if (result) {\n    return { message: 'Event added successfully' };\n  }\n  throw new BadRequestException('Could not add event');\n}\n</code></pre> <p>The Event module provides the core functionality for event management and user participation in the Tracery application.</p>"},{"location":"modules/ProfileModule/","title":"Profile Module","text":"<p>The <code>Profile Module</code> handles user profile operations in the Tracery application. It provides functionality for retrieving and managing <code>user</code> profile information while ensuring proper authentication.</p>"},{"location":"modules/ProfileModule/#core-components","title":"Core Components","text":""},{"location":"modules/ProfileModule/#profile-service","title":"Profile Service","text":"<p>The [<code>ProfileService</code>] handles profile-related business logic:</p> <pre><code>@Injectable()\nexport class ProfileService {\n  // Retrieve user profile with relationships\n  async getUserInfo(userId: number): Promise&lt;UserEntity | null&gt; {\n    const user = await this.userRepository.findOne({\n      where: { id: userId },\n      relations: [\"friends\", \"events\"],\n    });\n    return plainToInstance(UserEntity, user);\n  }\n}\n</code></pre>"},{"location":"modules/ProfileModule/#profile-controller","title":"Profile Controller","text":"<p>The [<code>ProfileController</code>] exposes profile-related endpoints:</p> <pre><code>@Controller(\"profile\")\n@UseGuards(AuthGuard) // Ensures all routes are protected\nexport class ProfileController {\n  @Get(\"/\")\n  async mainInfo(@Request() request: AuthorizedRequest) {\n    const { sub } = request.parsedToken;\n    const user = await this.profileService.getUserInfo(sub);\n    // Returns full user profile or 404\n  }\n}\n</code></pre>"},{"location":"modules/ProfileModule/#key-features","title":"Key Features","text":""},{"location":"modules/ProfileModule/#1-authentication-protection","title":"1. Authentication Protection","text":"<ul> <li>All routes are protected by AuthGuard</li> <li>Requires valid JWT token for access</li> <li>Automatically extracts user ID from token</li> </ul>"},{"location":"modules/ProfileModule/#profile-information","title":"Profile Information","text":"<ul> <li>Retrieves complete user profile</li> <li>Includes related data:</li> <li> <ul> <li>Friend relationships</li> </ul> </li> <li> <ul> <li>Event participations</li> </ul> </li> <li>Returns data in DTO format for security</li> </ul>"},{"location":"modules/ProfileModule/#error-handling","title":"Error Handling","text":"<ul> <li>Returns 404 for non-existent users</li> <li>Handles authentication errors</li> <li>Provides clear error messages</li> </ul>"},{"location":"modules/ProfileModule/#module-configuration","title":"Module Configuration","text":"<p>The Profile module is configured in <code>profile.module.ts</code>:</p> <pre><code>@Module({\n  imports: [TypeOrmModule.forFeature([UserEntity])],\n  controllers: [ProfileController],\n  providers: [ProfileService],\n})\nexport class ProfileModule {}\n</code></pre>"},{"location":"modules/ProfileModule/#api-endpoints","title":"API Endpoints","text":""},{"location":"modules/ProfileModule/#get-profile-information","title":"Get Profile Information","text":"<pre><code>GET /profile\nAuthorization: Bearer &lt;jwt_token&gt;\n</code></pre> <p>Request Body:</p> <p>No request body is required for this endpoint.</p> <p>Responses:</p> <ul> <li>200 OK</li> </ul> <p><code>json   {     \"id\": 1,     \"username\": \"johndoe\",     \"email\": \"johndoe@example.com\",     \"friends\": [       {         \"id\": 2,         \"username\": \"janedoe\"       }     ],     \"events\": [       {         \"id\": 1,         \"name\": \"Event 1\"       }     ]   }</code></p> <ul> <li>401 Unauthorized</li> </ul> <p><code>json   {     \"statusCode\": 401,     \"message\": \"Unauthorized\"   }</code></p> <ul> <li>404 Not Found</li> </ul> <p><code>json   {     \"statusCode\": 404,     \"message\": \"User not found\"   }</code></p>"},{"location":"modules/ProfileModule/#data-flow","title":"Data Flow","text":"<ol> <li>Client makes authenticated request to /profile</li> <li>AuthGuard validates JWT token</li> <li>User ID extracted from token payload</li> <li>ProfileService retrieves user data</li> <li>Data transformed through UserDto</li> <li>Response sent to client</li> </ol>"},{"location":"modules/ProfileModule/#usage-example","title":"Usage Example","text":"<pre><code>// Making an authenticated profile request\n@Get('/')\n@UseGuards(AuthGuard)\nasync mainInfo(@Request() request: AuthorizedRequest) {\n  const userId = request.parsedToken.sub;\n  const profile = await this.profileService.getUserInfo(userId);\n  if (!profile) {\n    throw new NotFoundException();\n  }\n  return profile;\n}\n</code></pre> <p>The Profile module provides essential functionality for retrieving and managing user profile information while maintaining security through authentication.</p>"},{"location":"modules/UserModule/","title":"User Module","text":"<p>The <code>User Module</code> manages user-related operations in the Tracery application. It provides functionality for user management, friend relationships, and user search capabilities.</p>"},{"location":"modules/UserModule/#core-components","title":"Core Components","text":""},{"location":"modules/UserModule/#user-service","title":"User Service","text":"<p>The [<code>UserService</code>] handles user-related business logic:</p> <pre><code>@Injectable()\nexport class UserService {\n  // Find all users with relationships\n  async findAll(): Promise&lt;UserDto[]&gt; {\n    const users = await this.userRepository.find({\n      relations: [\"friends\", \"events\"],\n    });\n    return users;\n  }\n\n  // Search users with pagination and fuzzy search\n  async searchFriends(page: number, search?: string) {\n    // Uses Levenshtein distance for nickname/email search\n    // Returns paginated results\n  }\n\n  // Manage friend relationships\n  async addFriend(userId: number, friendId: number) {\n    // Adds bidirectional friend relationship\n    // Prevents duplicate entries\n  }\n}\n</code></pre>"},{"location":"modules/UserModule/#user-controller","title":"User Controller","text":"<p>The [<code>UserController</code>] exposes REST endpoints:</p> <pre><code>@Controller(\"user\")\nexport class UserController {\n  @Get(\"/info/:id\")\n  async getUser(@Param(\"id\") id: number) {\n    // Returns user information\n  }\n\n  @Post(\"add-friend\")\n  @UseGuards(AuthGuard)\n  async addFriend(\n    @Request() request: AuthorizedRequest,\n    @Body(\"friendId\") friendId: number\n  ) {\n    // Protected endpoint for adding friends\n  }\n}\n</code></pre>"},{"location":"modules/UserModule/#key-features","title":"Key Features","text":""},{"location":"modules/UserModule/#user-management","title":"User Management","text":"<ul> <li>User information retrieval</li> <li>User search functionality</li> <li>Data transformation using UserDto</li> </ul>"},{"location":"modules/UserModule/#friend-system","title":"Friend System","text":"<ul> <li>Adding/removing friends</li> <li>Bidirectional friend relationships</li> <li>Friend search with pagination</li> </ul>"},{"location":"modules/UserModule/#search-functionality","title":"Search Functionality","text":"<ul> <li>Fuzzy search using <code>levenshtein</code> distance</li> <li>Searches through nicknames and emails</li> <li>Paginated results with configurable PAGE_SIZE</li> </ul>"},{"location":"modules/UserModule/#data-protection","title":"Data Protection","text":"<ul> <li>Route protection using AuthGuard</li> <li>Safe data transformation using DTOs</li> <li>Error handling for invalid operations</li> </ul>"},{"location":"modules/UserModule/#api-endpoints","title":"API Endpoints","text":""},{"location":"modules/UserModule/#get-user-information","title":"Get User Information","text":"<pre><code>GET /user/info/:id\n// Returns: UserDto with relationships\n</code></pre> <p>Request Body:</p> <ul> <li>None</li> </ul> <p>Responses:</p> <ul> <li><code>200 OK</code>: Returns the user information along with relationships.</li> <li><code>400 Bad Request</code>: Invalid user ID.</li> <li><code>404 Not Found</code>: User not found.</li> </ul>"},{"location":"modules/UserModule/#search-friends","title":"Search Friends","text":"<pre><code>GET /user/friends?page=1&amp;search=query\n// Returns: Paginated list of users\n</code></pre> <p>Request Body:</p> <ul> <li>None</li> </ul> <p>Responses:</p> <ul> <li><code>200 OK</code>: Returns a paginated list of users matching the search criteria.</li> <li><code>400 Bad Request</code>: Invalid query parameters.</li> </ul>"},{"location":"modules/UserModule/#add-friend","title":"Add Friend","text":"<pre><code>POST / user / add - friend;\nBody: {\n  friendId: number;\n}\n// Requires authentication\n</code></pre> <p>Request Body:</p> <ul> <li><code>friendId</code> (number): The ID of the friend to add.</li> </ul> <p>Responses:</p> <ul> <li><code>200 OK</code>: Friend added successfully.</li> <li><code>400 Bad Request</code>: Invalid friend ID or friend already added.</li> <li><code>401 Unauthorized</code>: User not authenticated.</li> </ul>"},{"location":"modules/UserModule/#remove-friend","title":"Remove Friend","text":"<pre><code>DELETE / user / remove - friend;\nBody: {\n  friendId: number;\n}\n// Requires authentication\n</code></pre> <p>Request Body:</p> <ul> <li><code>friendId</code> (number): The ID of the friend to remove.</li> </ul> <p>Responses:</p> <ul> <li><code>200 OK</code>: Friend removed successfully.</li> <li><code>400 Bad Request</code>: Invalid friend ID or friend not found.</li> <li><code>401 Unauthorized</code>: User not authenticated.</li> </ul>"},{"location":"modules/UserModule/#module-configuration","title":"Module Configuration","text":"<p>The User module is configured in <code>user.module.ts</code>:</p> <pre><code>@Module({\n  imports: [TypeOrmModule.forFeature([UserEntity])],\n  controllers: [UserController],\n  providers: [UserService],\n  exports: [UserService],\n})\nexport class UserModule {}\n</code></pre>"},{"location":"modules/UserModule/#usage-example","title":"Usage Example","text":"<pre><code>// Adding a friend with bidirectional relationship\n@Post('add-friend')\n@UseGuards(AuthGuard)\nasync addFriend(\n  @Request() request: AuthorizedRequest,\n  @Body('friendId') friendId: number,\n) {\n  const userId = request.parsedToken.sub\n  const result = await this.userService.addFriend(userId, friendId) &amp;&amp;\n                 await this.userService.addFriend(friendId, userId)\n\n  if (result) {\n    return { message: 'Friend added successfully' }\n  }\n  throw new BadRequestException('Could not add friend')\n}\n</code></pre> <p>The User module provides essential functionality for user management and social features in the Tracery application.</p>"}]}