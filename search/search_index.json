{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome!","text":"<p>Here you will find information that will help you to get started developing the Tracery application.</p> <p>The documentation tries to address the following questions:</p> <ol> <li>Code Style</li> <li>Project structure</li> <li>Third-party Libraries</li> <li>Project modules</li> </ol>"},{"location":"code-style/","title":"Code Style","text":"<p>Here is the guide how to properly write your TypeScript code. It doesn't cover the best practises of libraries or tools. To learn more about, let's say, React, go to the proper section.</p>"},{"location":"code-style/#pascalcase-is-the-way","title":"PascalCase is the way","text":"<p>Always use 1. PascalCase for classes or 2. pascalCase for everything else</p> <pre><code>class HumanManager { // Here PascalCase\n  constructor (\n    private readonly name: string,\n    private readonly surname: string,\n  ) {}\n\n  get fullName(): string { // ...and here pascalCase\n    return `${this.name} ${this.surname}`\n  }\n}\n\n// Here, again, pascalCase\nconst reallyLongIdentifier = new HumanManager('Mateusz', 'Nowak')\n</code></pre>"},{"location":"code-style/#tab-size-is-2-spaces","title":"Tab size is 2 spaces","text":"<p>You will deal with deeply nested JSX tags, like:</p> <pre><code>&lt;Container&gt;\n  &lt;Section&gt;\n    &lt;AnotherSection&gt;\n      &lt;SomeComponent /&gt;\n    &lt;/AnotherSection&gt;\n  &lt;/Section&gt;\n&lt;/Container&gt;\n</code></pre> <p>having tab size being equal to 4 spaces makes your code less readable. Tab size of 2 makes code more compact, therefore much more readable</p>"},{"location":"code-style/#dont-use-semicolons-unless-really-needed","title":"Don't use semicolons (unless really needed)","text":"<pre><code>const a = 1\nconst b = 2\nconsole.log(a + b)\n</code></pre> <p>TypeScript compiles down to JavaScript with automatically inserted semicolons. In some rare cases, however, they are necessary, and only then they should be inserted. If you see red errors around [] or (), try inserting a semicolon</p>"},{"location":"code-style/#try-not-to-omit-brackets-in-compound-statements","title":"Try not to omit brackets in compound statements","text":"<pre><code>// Bad\nif (something)\n  doSomething()\n\n// Good\nif (something) {\n  doSomething()\n}\n</code></pre>"},{"location":"code-style/#embrace-single-quotes","title":"Embrace single quotes:","text":"<pre><code>import { React } from 'react'\nimport { css } from 'styled-components'\n</code></pre> <p>They are faster to type. It will be a standard preference for our codebase. Use double quotes only when the string contains a single quote:</p> <pre><code>const quotedString = \"'Mateusz'\"\n</code></pre>"},{"location":"code-style/#dont-write-long-lines-split-them","title":"Don't write long lines. Split them!","text":"<pre><code>// Bad\nconst measurement = measureVelocity(valueA, valueB, valueC, valueD, valueE)\n\n// Good\nconst measurement = measureVelocity(\n  valueA,\n  valueB,\n  valueC,\n  valueD,\n  valueE,\n)\n\n// Bad\n&lt;MyComponent propA={{ ...something }} propB={10.0} propC /&gt;\n\n// Good\n&lt;MyComponent\n  propA={\n    ...something,\n  }}\n  propB={10.0}\n  propC\n/&gt;\n</code></pre>"},{"location":"code-style/#use-trailing-commas","title":"Use trailing commas","text":"<p>JavaScript allows you to have trailing commas in function calls, objects and arrays</p> <pre><code>const schema = {\n  type: 'post',\n  payload: {\n    name: 'Mateusz',\n    surname: 'Nowak', // here is trailing comma\n  }, // here is trailing comma\n}\n</code></pre>"},{"location":"code-style/#use-arrow-functions","title":"Use arrow functions","text":"<p>Arrow functions' behavior is more predictable (I am primarily talking about this). Therefore, when possible, you should use them:</p> <pre><code>\n// an arrow function\nconst App = () =&gt; {\n  return (\n    &lt;main&gt;\n      &lt;h1&gt;Hello, world!&lt;/h1&gt;\n    &lt;/main&gt;\n  )\n}\n\n// another arrow function\nconst add = (a: number, b: number) =&gt; a + b\n\n// you can use them as methods in classes\nclass Person {\n  constructor (\n    public readonly name: string,\n    public readonly surname: string,\n  ) {}\n\n  greet = (friend: Person) =&gt; {\n    const greeting = `Hi, ${friend.name}, I am ${this.name}!`\n    console.log(greeting)\n  }\n}\n\n</code></pre>"},{"location":"code-style/#allow-typescript-to-infer-types-when-possible","title":"Allow TypeScript to infer types when possible","text":"<p>TypeScript type inference works well most of the times. In fact, when type inference is possible, TypeScript will definitely infer types better than you. So, use types only when needed (normally for function arguments)</p> <pre><code>// Not needed - TypeScript already knows that a is a string\nconst a: string = 'Hello, world' // type of a is 'string'\n\nconst a = 'Hello, world!' // type of a is a literal 'Hello, world!'\n                          // the type here is more narrow since TypeScript\n                          // knows that a cannot be changed to\n                          // any other string\n\n// why do you need \": number\" in the end?\nconst add = (a: number, b: number): number =&gt; a + b\n\n// this one is better: TS already knows \n// that the function returns a number\nconst add = (a: number, b: number) =&gt; a + b\n</code></pre>"},{"location":"code-style/#dont-use-any","title":"Don't use any","text":"<p>Type 'any' kills the TypeScript type system. The moment you introduce 'any' to your codebase, you allow bad things to happen. Don't do that.</p> <p>Consider reading on the internet how to:</p> <ol> <li>Use 'unknown' type instead</li> <li>Use generics</li> <li>Use type guards with validation</li> </ol> <p>Normally 'any' occurs when you get something as a network response. Then, you need to validate the response and prove that it has the desired type using type guards</p> <pre><code>// Example of a type guard validation\n\ntype Person = {\n  name: string\n  surname: string\n}\n\nconst isPerson = (maybePerson: unknown): maybePerson is Person =&gt; {\n  if (maybePerson === undefined || maybePerson === null) {\n    return false\n  }\n  if (typeof maybePerson !== 'object') {\n    return false\n  }\n  if (typeof maybePerson?.name !== 'string' ||\n      typeof maybePerson?.surname !== 'string) {\n    return false\n  }\n  return true\n}\n\n// in some other place\nconst person = await fetchPerson() // type of person is any\nif (isPerson(person)) {\n  // Here TypeScript knows, \n  // that if isPerson returned true,\n  // type of the person is Person\n  console.log(person.name) // No error\n}\n\n</code></pre>"},{"location":"code-style/#dont-use-typescript-enums-and-namespaces","title":"Don't use TypeScript enums and namespaces","text":"<p>Instead of enums you can use const enums. Namespaces are just a language design mistake, nobody uses them, so you shouldn't either</p>"},{"location":"code-style/#use-typescript-const-enums","title":"Use TypeScript const enums","text":"<p>const enums are quite useful. They are similar to C macroses. During compilation, they are turned into just JavaScript literals</p> <pre><code>const enum Status {\n  ON = 'On',\n  OFF = 'Off',\n  UNKNOWN = 'Unknown'\n}\n\nconst status = Status.OFF // after compilation,\n                          // it will be just const status = 'Off'\n\n// You can skip literals in const enum definition,\n// then TypeScript will use numbers 0, 1, 2, ...\nconst enum Flag {\n  READ,\n  WRITE,\n}\n\nconst flag = Flag.READ // after compilation,\n                       // const flag = 0\n</code></pre>"},{"location":"code-style/#dont-use-interfaces-use-types-instead","title":"Don't use interfaces, use types instead","text":"<p>Attention! Both types and interfaces do the same thing!    In other languages there may be a distinction between those two.   TypeScript, however, is a language with duck typing, therefore   each type acts as an interface by default </p> <p>In TypeScript you have two ways of declaring a type:</p> <ol> <li>Interface declaration</li> <li>Type declaration</li> </ol> <pre><code>// preferred way\ntype User = {\n  name: string\n  surname: string\n}\n\n// Bad - don't use it\ninterface User {\n  name: string\n  surname: string\n}\n</code></pre> <p>The reason behind this decision is the fact that interfaces are quite limited, and all their use-cases are covered with type definitions.</p>"},{"location":"code-style/#ask-about-the-rest","title":"Ask about the rest","text":"<p>If you are unsure about something, just ask me :)</p>"}]}